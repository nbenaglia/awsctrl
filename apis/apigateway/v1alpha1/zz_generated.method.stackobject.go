/*
Copyright Â© 2019 AWS Controller authors

Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
	"fmt"
	"reflect"
	"strings"

	metav1alpha1 "go.awsctrl.io/manager/apis/meta/v1alpha1"
	controllerutils "go.awsctrl.io/manager/controllers/utils"
	cfnencoder "go.awsctrl.io/manager/encoding/cloudformation"

	"github.com/awslabs/goformation/v4/cloudformation"
	"github.com/awslabs/goformation/v4/cloudformation/apigateway"
	"k8s.io/client-go/dynamic"
)

// GetNotificationARNs is an autogenerated deepcopy function, will return notifications for stack
func (in *Method) GetNotificationARNs() []string {
	notifcations := []string{}
	for _, notifarn := range in.Spec.NotificationARNs {
		notifcations = append(notifcations, *notifarn)
	}
	return notifcations
}

// GetTemplate will return the JSON version of the CFN to use.
func (in *Method) GetTemplate(client dynamic.Interface) (string, error) {
	if client == nil {
		return "", fmt.Errorf("k8s client not loaded for template")
	}
	template := cloudformation.NewTemplate()

	template.Description = "AWS Controller - apigateway.Method (ac-{TODO})"

	template.Outputs = map[string]interface{}{
		"ResourceRef": map[string]interface{}{
			"Value": cloudformation.Ref("Method"),
			"Export": map[string]interface{}{
				"Name": in.Name + "Ref",
			},
		},
	}

	apigatewayMethod := &apigateway.Method{}

	if len(in.Spec.AuthorizationScopes) > 0 {
		apigatewayMethod.AuthorizationScopes = in.Spec.AuthorizationScopes
	}

	if !reflect.DeepEqual(in.Spec.Integration, Method_Integration{}) {
		apigatewayMethodIntegration := apigateway.Method_Integration{}

		if in.Spec.Integration.TimeoutInMillis != apigatewayMethodIntegration.TimeoutInMillis {
			apigatewayMethodIntegration.TimeoutInMillis = in.Spec.Integration.TimeoutInMillis
		}

		if len(in.Spec.Integration.CacheKeyParameters) > 0 {
			apigatewayMethodIntegration.CacheKeyParameters = in.Spec.Integration.CacheKeyParameters
		}

		apigatewayMethodIntegrationIntegrationResponses := []apigateway.Method_IntegrationResponse{}

		for _, item := range in.Spec.Integration.IntegrationResponses {
			apigatewayMethodIntegrationIntegrationResponse := apigateway.Method_IntegrationResponse{}

			if item.ContentHandling != "" {
				apigatewayMethodIntegrationIntegrationResponse.ContentHandling = item.ContentHandling
			}

			if !reflect.DeepEqual(item.ResponseParameters, map[string]string{}) {
				apigatewayMethodIntegrationIntegrationResponse.ResponseParameters = item.ResponseParameters
			}

			if !reflect.DeepEqual(item.ResponseTemplates, map[string]string{}) {
				apigatewayMethodIntegrationIntegrationResponse.ResponseTemplates = item.ResponseTemplates
			}

			if item.SelectionPattern != "" {
				apigatewayMethodIntegrationIntegrationResponse.SelectionPattern = item.SelectionPattern
			}

			if item.StatusCode != "" {
				apigatewayMethodIntegrationIntegrationResponse.StatusCode = item.StatusCode
			}

		}

		if len(apigatewayMethodIntegrationIntegrationResponses) > 0 {
			apigatewayMethodIntegration.IntegrationResponses = apigatewayMethodIntegrationIntegrationResponses
		}
		if in.Spec.Integration.IntegrationHttpMethod != "" {
			apigatewayMethodIntegration.IntegrationHttpMethod = in.Spec.Integration.IntegrationHttpMethod
		}

		if !reflect.DeepEqual(in.Spec.Integration.RequestTemplates, map[string]string{}) {
			apigatewayMethodIntegration.RequestTemplates = in.Spec.Integration.RequestTemplates
		}

		if in.Spec.Integration.Uri != "" {
			apigatewayMethodIntegration.Uri = in.Spec.Integration.Uri
		}

		if in.Spec.Integration.ConnectionType != "" {
			apigatewayMethodIntegration.ConnectionType = in.Spec.Integration.ConnectionType
		}

		if in.Spec.Integration.ContentHandling != "" {
			apigatewayMethodIntegration.ContentHandling = in.Spec.Integration.ContentHandling
		}

		if !reflect.DeepEqual(in.Spec.Integration.RequestParameters, map[string]string{}) {
			apigatewayMethodIntegration.RequestParameters = in.Spec.Integration.RequestParameters
		}

		if in.Spec.Integration.Type != "" {
			apigatewayMethodIntegration.Type = in.Spec.Integration.Type
		}

		if in.Spec.Integration.CacheNamespace != "" {
			apigatewayMethodIntegration.CacheNamespace = in.Spec.Integration.CacheNamespace
		}

		// TODO(christopherhein) move these to a defaulter
		apigatewayMethodIntegrationConnectionRefItem := in.Spec.Integration.ConnectionRef.DeepCopy()

		if apigatewayMethodIntegrationConnectionRefItem.ObjectRef.Namespace == "" {
			apigatewayMethodIntegrationConnectionRefItem.ObjectRef.Namespace = in.Namespace
		}

		in.Spec.Integration.ConnectionRef = *apigatewayMethodIntegrationConnectionRefItem
		connectionId, err := in.Spec.Integration.ConnectionRef.String(client)
		if err != nil {
			return "", err
		}

		if connectionId != "" {
			apigatewayMethodIntegration.ConnectionId = connectionId
		}

		if in.Spec.Integration.Credentials != "" {
			apigatewayMethodIntegration.Credentials = in.Spec.Integration.Credentials
		}

		if in.Spec.Integration.PassthroughBehavior != "" {
			apigatewayMethodIntegration.PassthroughBehavior = in.Spec.Integration.PassthroughBehavior
		}

		apigatewayMethod.Integration = &apigatewayMethodIntegration
	}

	if in.Spec.OperationName != "" {
		apigatewayMethod.OperationName = in.Spec.OperationName
	}

	if in.Spec.AuthorizationType != "" {
		apigatewayMethod.AuthorizationType = in.Spec.AuthorizationType
	}

	// TODO(christopherhein) move these to a defaulter
	apigatewayMethodAuthorizerRefItem := in.Spec.AuthorizerRef.DeepCopy()

	if apigatewayMethodAuthorizerRefItem.ObjectRef.Namespace == "" {
		apigatewayMethodAuthorizerRefItem.ObjectRef.Namespace = in.Namespace
	}

	in.Spec.AuthorizerRef = *apigatewayMethodAuthorizerRefItem
	authorizerId, err := in.Spec.AuthorizerRef.String(client)
	if err != nil {
		return "", err
	}

	if authorizerId != "" {
		apigatewayMethod.AuthorizerId = authorizerId
	}

	apigatewayMethodMethodResponses := []apigateway.Method_MethodResponse{}

	for _, item := range in.Spec.MethodResponses {
		apigatewayMethodMethodResponse := apigateway.Method_MethodResponse{}

		if !reflect.DeepEqual(item.ResponseModels, map[string]string{}) {
			apigatewayMethodMethodResponse.ResponseModels = item.ResponseModels
		}

		if !reflect.DeepEqual(item.ResponseParameters, map[string]bool{}) {
			apigatewayMethodMethodResponse.ResponseParameters = item.ResponseParameters
		}

		if item.StatusCode != "" {
			apigatewayMethodMethodResponse.StatusCode = item.StatusCode
		}

	}

	if len(apigatewayMethodMethodResponses) > 0 {
		apigatewayMethod.MethodResponses = apigatewayMethodMethodResponses
	}
	if in.Spec.HttpMethod != "" {
		apigatewayMethod.HttpMethod = in.Spec.HttpMethod
	}

	if !reflect.DeepEqual(in.Spec.RequestModels, map[string]string{}) {
		apigatewayMethod.RequestModels = in.Spec.RequestModels
	}

	// TODO(christopherhein) move these to a defaulter
	apigatewayMethodRequestValidatorRefItem := in.Spec.RequestValidatorRef.DeepCopy()

	if apigatewayMethodRequestValidatorRefItem.ObjectRef.Namespace == "" {
		apigatewayMethodRequestValidatorRefItem.ObjectRef.Namespace = in.Namespace
	}

	in.Spec.RequestValidatorRef = *apigatewayMethodRequestValidatorRefItem
	requestValidatorId, err := in.Spec.RequestValidatorRef.String(client)
	if err != nil {
		return "", err
	}

	if requestValidatorId != "" {
		apigatewayMethod.RequestValidatorId = requestValidatorId
	}

	// TODO(christopherhein) move these to a defaulter
	apigatewayMethodResourceRefItem := in.Spec.ResourceRef.DeepCopy()

	if apigatewayMethodResourceRefItem.ObjectRef.Namespace == "" {
		apigatewayMethodResourceRefItem.ObjectRef.Namespace = in.Namespace
	}

	in.Spec.ResourceRef = *apigatewayMethodResourceRefItem
	resourceId, err := in.Spec.ResourceRef.String(client)
	if err != nil {
		return "", err
	}

	if resourceId != "" {
		apigatewayMethod.ResourceId = resourceId
	}

	if in.Spec.ApiKeyRequired || !in.Spec.ApiKeyRequired {
		apigatewayMethod.ApiKeyRequired = in.Spec.ApiKeyRequired
	}

	if !reflect.DeepEqual(in.Spec.RequestParameters, map[string]bool{}) {
		apigatewayMethod.RequestParameters = in.Spec.RequestParameters
	}

	// TODO(christopherhein) move these to a defaulter
	apigatewayMethodRestApiRefItem := in.Spec.RestApiRef.DeepCopy()

	if apigatewayMethodRestApiRefItem.ObjectRef.Namespace == "" {
		apigatewayMethodRestApiRefItem.ObjectRef.Namespace = in.Namespace
	}

	in.Spec.RestApiRef = *apigatewayMethodRestApiRefItem
	restApiId, err := in.Spec.RestApiRef.String(client)
	if err != nil {
		return "", err
	}

	if restApiId != "" {
		apigatewayMethod.RestApiId = restApiId
	}

	template.Resources = map[string]cloudformation.Resource{
		"Method": apigatewayMethod,
	}

	// json, err := template.JSONWithOptions(&intrinsics.ProcessorOptions{NoEvaluateConditions: true})
	json, err := template.JSON()
	if err != nil {
		return "", err
	}

	return string(json), nil
}

// GetStackID will return stackID
func (in *Method) GetStackID() string {
	return in.Status.StackID
}

// GenerateStackName will generate a StackName
func (in *Method) GenerateStackName() string {
	return strings.Join([]string{"apigateway", "method", in.GetName(), in.GetNamespace()}, "-")
}

// GetStackName will return stackName
func (in *Method) GetStackName() string {
	return in.Spec.StackName
}

// GetTemplateVersionLabel will return the stack template version
func (in *Method) GetTemplateVersionLabel() (value string, ok bool) {
	value, ok = in.Labels[controllerutils.StackTemplateVersionLabel]
	return
}

// GetParameters will return CFN Parameters
func (in *Method) GetParameters() map[string]string {
	params := map[string]string{}
	cfnencoder.MarshalTypes(params, in.Spec, "Parameter")
	return params
}

// GetCloudFormationMeta will return CFN meta object
func (in *Method) GetCloudFormationMeta() metav1alpha1.CloudFormationMeta {
	return in.Spec.CloudFormationMeta
}

// GetStatus will return the CFN Status
func (in *Method) GetStatus() metav1alpha1.ConditionStatus {
	return in.Status.Status
}

// SetStackID will put a stackID
func (in *Method) SetStackID(input string) {
	in.Status.StackID = input
	return
}

// SetStackName will return stackName
func (in *Method) SetStackName(input string) {
	in.Spec.StackName = input
	return
}

// SetTemplateVersionLabel will set the template version label
func (in *Method) SetTemplateVersionLabel() {
	if len(in.Labels) == 0 {
		in.Labels = map[string]string{}
	}

	in.Labels[controllerutils.StackTemplateVersionLabel] = controllerutils.ComputeHash(in.Spec)
}

// TemplateVersionChanged will return bool if template has changed
func (in *Method) TemplateVersionChanged() bool {
	// Ignore bool since it will still record changed
	label, _ := in.GetTemplateVersionLabel()
	return label != controllerutils.ComputeHash(in.Spec)
}

// SetStatus will set status for object
func (in *Method) SetStatus(status *metav1alpha1.StatusMeta) {
	in.Status.StatusMeta = *status
}
